{
  "useAbortableFetch": "import { useCallback, useRef, useState } from \"react\";\nfunction useAbortableFetch() {\n  const controllerRef = useRef(null);\n  const [loading, setLoading] = useState(false);\n  const [data, setData] = useState(null);\n  const [error, setError] = useState(null);\n  const fetcher = useCallback(async (input, init) => {\n    var _a;\n    (_a = controllerRef.current) == null ? void 0 : _a.abort();\n    const ctrl = new AbortController();\n    controllerRef.current = ctrl;\n    setLoading(true);\n    setError(null);\n    try {\n      const res = await fetch(input, { ...init || {}, signal: ctrl.signal });\n      if (!res.ok)\n        throw new Error(`${res.status} ${res.statusText}`);\n      const json = await res.json();\n      setData(json);\n      return json;\n    } catch (err) {\n      if (err.name === \"AbortError\")\n        return;\n      setError(err);\n      throw err;\n    } finally {\n      setLoading(false);\n    }\n  }, []);\n  const abort = useCallback(() => {\n    var _a;\n    return (_a = controllerRef.current) == null ? void 0 : _a.abort();\n  }, []);\n  return { data, error, loading, fetch: fetcher, abort };\n}\nexport {\n  useAbortableFetch\n};\n",
  "useBoolean": "import { useCallback, useState } from \"react\";\nfunction useBoolean(initial = false) {\n  const [value, setValue] = useState(initial);\n  const setTrue = useCallback(() => setValue(true), []);\n  const setFalse = useCallback(() => setValue(false), []);\n  const toggle = useCallback(() => setValue((v) => !v), []);\n  return { value, setTrue, setFalse, toggle };\n}\nexport {\n  useBoolean\n};\n",
  "useBroadcastChannel": "import { useEffect, useRef } from \"react\";\nfunction useBroadcastChannel(name) {\n  const bcRef = useRef(null);\n  useEffect(() => {\n    if (typeof BroadcastChannel === \"undefined\")\n      return;\n    bcRef.current = new BroadcastChannel(name);\n    return () => {\n      var _a;\n      return (_a = bcRef.current) == null ? void 0 : _a.close();\n    };\n  }, [name]);\n  const post = (msg) => {\n    var _a;\n    return (_a = bcRef.current) == null ? void 0 : _a.postMessage(msg);\n  };\n  const subscribe = (handler) => {\n    const ch = bcRef.current;\n    if (!ch)\n      return () => {\n      };\n    ch.addEventListener(\"message\", handler);\n    return () => ch.removeEventListener(\"message\", handler);\n  };\n  return { post, subscribe, channel: bcRef };\n}\nexport {\n  useBroadcastChannel\n};\n",
  "useClickOutside": "import { useEffect } from \"react\";\nfunction useClickOutside(ref, handler) {\n  useEffect(() => {\n    const listener = (e) => {\n      const el = ref == null ? void 0 : ref.current;\n      if (!el)\n        return;\n      if (e.target instanceof Node && el.contains(e.target))\n        return;\n      handler(e);\n    };\n    document.addEventListener(\"mousedown\", listener);\n    document.addEventListener(\"touchstart\", listener);\n    return () => {\n      document.removeEventListener(\"mousedown\", listener);\n      document.removeEventListener(\"touchstart\", listener);\n    };\n  }, [ref, handler]);\n}\nexport {\n  useClickOutside\n};\n",
  "useClipboard": "import { useCallback, useState } from \"react\";\nimport { isClient } from \"../utils/ssr\";\nfunction useClipboard() {\n  const [isCopying, setIsCopying] = useState(false);\n  const [lastCopied, setLastCopied] = useState(null);\n  const supported = isClient && !!(navigator.clipboard && navigator.clipboard.writeText);\n  const copy = useCallback(async (text) => {\n    if (!supported)\n      return false;\n    setIsCopying(true);\n    try {\n      await navigator.clipboard.writeText(text);\n      setLastCopied(text);\n      return true;\n    } catch (err) {\n      console.warn(\"useClipboard: copy failed\", err);\n      return false;\n    } finally {\n      setIsCopying(false);\n    }\n  }, [supported]);\n  return { copy, supported, isCopying, lastCopied };\n}\nexport {\n  useClipboard\n};\n",
  "useDarkMode": "import { useEffect, useState } from \"react\";\nfunction useDarkMode(key = \"use-dark-mode\") {\n  const isClient = typeof window !== \"undefined\";\n  const prefersDark = isClient && window.matchMedia && window.matchMedia(\"(prefers-color-scheme: dark)\").matches;\n  const [isDark, setIsDark] = useState(() => {\n    if (!isClient)\n      return false;\n    const raw = localStorage.getItem(key);\n    if (raw !== null)\n      return raw === \"true\";\n    return prefersDark;\n  });\n  useEffect(() => {\n    if (!isClient)\n      return;\n    document.documentElement.dataset.theme = isDark ? \"dark\" : \"light\";\n    localStorage.setItem(key, String(isDark));\n  }, [isDark, key, isClient]);\n  useEffect(() => {\n    if (!isClient)\n      return;\n    const mm = window.matchMedia(\"(prefers-color-scheme: dark)\");\n    const onChange = (e) => setIsDark((prev) => {\n      const saved = localStorage.getItem(key);\n      if (saved !== null)\n        return prev;\n      return e.matches;\n    });\n    if (typeof mm.addEventListener === \"function\") {\n      mm.addEventListener(\"change\", onChange);\n      return () => mm.removeEventListener(\"change\", onChange);\n    }\n    const legacy = mm;\n    if (legacy.addListener)\n      legacy.addListener(onChange);\n    return () => {\n      if (legacy.removeListener)\n        legacy.removeListener(onChange);\n    };\n  }, [key, isClient]);\n  const toggle = () => setIsDark((d) => !d);\n  return { isDark, setIsDark, toggle };\n}\nexport {\n  useDarkMode\n};\n",
  "useDebounce": "import { useEffect, useState } from \"react\";\nfunction useDebounce(value, delay = 300) {\n  const [debounced, setDebounced] = useState(value);\n  useEffect(() => {\n    if (delay <= 0) {\n      const id = setTimeout(() => setDebounced(value), 0);\n      return () => clearTimeout(id);\n    }\n    const t = setTimeout(() => setDebounced(value), delay);\n    return () => clearTimeout(t);\n  }, [value, delay]);\n  return debounced;\n}\nexport {\n  useDebounce\n};\n",
  "useDidMount": "import { useEffect, useRef } from \"react\";\nfunction useDidMount(fn) {\n  const saved = useRef(fn);\n  useEffect(() => {\n    saved.current = fn;\n  }, [fn]);\n  useEffect(() => {\n    saved.current();\n  }, []);\n}\nexport {\n  useDidMount\n};\n",
  "useDidUpdate": "import { useEffect, useRef } from \"react\";\nfunction useDidUpdate(fn, deps) {\n  const mounted = useRef(false);\n  useEffect(() => {\n    if (!mounted.current) {\n      mounted.current = true;\n      return;\n    }\n    const cleanup = fn();\n    return typeof cleanup === \"function\" ? cleanup : void 0;\n  }, deps);\n}\nexport {\n  useDidUpdate\n};\n",
  "useElementSize": "import { useEffect, useState } from \"react\";\nfunction useElementSize() {\n  const [el, setEl] = useState(null);\n  const [size, setSize] = useState({ width: 0, height: 0 });\n  useEffect(() => {\n    if (!el || typeof ResizeObserver === \"undefined\")\n      return;\n    const obs = new ResizeObserver((entries) => {\n      for (const entry of entries) {\n        const cr = entry.contentRect;\n        setSize({ width: cr.width, height: cr.height });\n      }\n    });\n    obs.observe(el);\n    return () => obs.disconnect();\n  }, [el]);\n  return { ref: setEl, size };\n}\nexport {\n  useElementSize\n};\n",
  "useEventListener": "import { useEffect, useRef } from \"react\";\nfunction useEventListener(eventName, handler, element = typeof window !== \"undefined\" ? window : null) {\n  const saved = useRef(handler);\n  useEffect(() => {\n    saved.current = handler;\n  }, [handler]);\n  useEffect(() => {\n    if (!element || !element.addEventListener)\n      return;\n    const listener = (e) => saved.current(e);\n    element.addEventListener(eventName, listener);\n    return () => element.removeEventListener(eventName, listener);\n  }, [eventName, element]);\n}\nexport {\n  useEventListener\n};\n",
  "useFetch": "import { useCallback, useEffect, useRef, useState } from \"react\";\nfunction useFetch(url, options) {\n  const [state, setState] = useState({ data: null, error: null, loading: !!url });\n  const controllerRef = useRef(null);\n  const savedUrl = useRef(url);\n  const fetcher = useCallback(async (input) => {\n    var _a;\n    const target = input != null ? input : url;\n    if (!target)\n      return;\n    (_a = controllerRef.current) == null ? void 0 : _a.abort();\n    const ctrl = new AbortController();\n    controllerRef.current = ctrl;\n    setState((s) => ({ ...s, loading: true }));\n    try {\n      const res = await fetch(target, { signal: ctrl.signal, ...options || {} });\n      if (!res.ok)\n        throw new Error(`${res.status} ${res.statusText}`);\n      const data = await res.json();\n      setState({ data, error: null, loading: false });\n      return data;\n    } catch (err) {\n      const name = err.name;\n      if (name === \"AbortError\")\n        return;\n      setState({ data: null, error: err, loading: false });\n      throw err;\n    }\n  }, [url, options]);\n  useEffect(() => {\n    if (!url)\n      return;\n    savedUrl.current = url;\n    fetcher(url).catch(() => {\n    });\n    return () => {\n      var _a;\n      (_a = controllerRef.current) == null ? void 0 : _a.abort();\n    };\n  }, [url, fetcher]);\n  const refetch = useCallback(() => fetcher(savedUrl.current), [fetcher]);\n  return { ...state, refetch };\n}\nexport {\n  useFetch\n};\n",
  "useFetchWithRetry": "import { useCallback } from \"react\";\nimport { useFetch } from \"./useFetch\";\nfunction useFetchWithRetry(url, options, retries = 2, delay = 500) {\n  const base = useFetch(url, options);\n  const retry = useCallback(async () => {\n    for (let i = 0; i <= retries; i++) {\n      try {\n        await base.refetch();\n        return;\n      } catch (err) {\n        if (i === retries)\n          throw err;\n        await new Promise((res) => setTimeout(res, delay));\n      }\n    }\n  }, [base, retries, delay]);\n  return { ...base, retry };\n}\nexport {\n  useFetchWithRetry\n};\n",
  "useGeolocation": "import { useCallback, useEffect, useRef, useState } from \"react\";\nfunction useGeolocation(options) {\n  const [position, setPosition] = useState(null);\n  const [error, setError] = useState(null);\n  const watchId = useRef(null);\n  const [watching, setWatching] = useState(false);\n  const start = useCallback(() => {\n    if (!(\"geolocation\" in navigator))\n      return;\n    if (watchId.current != null)\n      return;\n    watchId.current = navigator.geolocation.watchPosition(\n      (pos) => setPosition({ latitude: pos.coords.latitude, longitude: pos.coords.longitude, accuracy: pos.coords.accuracy }),\n      (err) => setError(err),\n      options\n    );\n    setWatching(true);\n  }, [options]);\n  const stop = useCallback(() => {\n    if (watchId.current != null) {\n      navigator.geolocation.clearWatch(watchId.current);\n      watchId.current = null;\n    }\n    setWatching(false);\n  }, []);\n  useEffect(() => {\n    const id = setTimeout(() => start(), 0);\n    return () => {\n      clearTimeout(id);\n      stop();\n    };\n  }, [start, stop]);\n  return { position, error, watching, start, stop };\n}\nexport {\n  useGeolocation\n};\n",
  "useInfiniteScroll": "import { useCallback, useEffect, useRef, useState } from \"react\";\nfunction useInfiniteScroll(loader) {\n  const [items, setItems] = useState([]);\n  const [loading, setLoading] = useState(false);\n  const observerRef = useRef(null);\n  const sentinelRef = useRef(null);\n  const loadMore = useCallback(async () => {\n    setLoading(true);\n    try {\n      const next = await loader();\n      setItems((prev) => [...prev, ...next]);\n    } finally {\n      setLoading(false);\n    }\n  }, [loader]);\n  useEffect(() => {\n    if (!(\"IntersectionObserver\" in window))\n      return;\n    observerRef.current = new IntersectionObserver((entries) => {\n      entries.forEach((e) => {\n        if (e.isIntersecting)\n          loadMore();\n      });\n    });\n    const obs = observerRef.current;\n    const el = sentinelRef.current;\n    if (el)\n      obs.observe(el);\n    return () => {\n      if (el)\n        obs.unobserve(el);\n    };\n  }, [loadMore]);\n  return { items, loading, sentinelRef: (el) => {\n    sentinelRef.current = el;\n  }, loadMore };\n}\nexport {\n  useInfiniteScroll\n};\n",
  "useIntersectionObserver": "import { useEffect, useRef, useState } from \"react\";\nfunction useIntersectionObserver(options) {\n  const observerRef = useRef(null);\n  const [entries, setEntries] = useState([]);\n  useEffect(() => {\n    if (typeof IntersectionObserver === \"undefined\")\n      return;\n    observerRef.current = new IntersectionObserver((ent) => setEntries(ent), options);\n    return () => {\n      var _a;\n      (_a = observerRef.current) == null ? void 0 : _a.disconnect();\n    };\n  }, [options]);\n  const observe = (el) => {\n    if (el && observerRef.current)\n      observerRef.current.observe(el);\n  };\n  const unobserve = (el) => {\n    if (el && observerRef.current)\n      observerRef.current.unobserve(el);\n  };\n  return { entries, observe, unobserve };\n}\nexport {\n  useIntersectionObserver\n};\n",
  "useInterval": "import { useEffect, useRef } from \"react\";\nfunction useInterval(cb, delay, immediate = false) {\n  const saved = useRef(cb);\n  useEffect(() => {\n    saved.current = cb;\n  }, [cb]);\n  useEffect(() => {\n    if (delay == null)\n      return;\n    if (immediate)\n      saved.current();\n    const id = setInterval(() => saved.current(), delay);\n    return () => clearInterval(id);\n  }, [delay, immediate]);\n}\nexport {\n  useInterval\n};\n",
  "useIsFirstRender": "import { useEffect, useState } from \"react\";\nfunction useIsFirstRender() {\n  const [first, setFirst] = useState(true);\n  useEffect(() => {\n    const id = setTimeout(() => setFirst(false), 0);\n    return () => clearTimeout(id);\n  }, []);\n  return first;\n}\nexport {\n  useIsFirstRender\n};\n",
  "useKeyPress": "import { useEffect, useState } from \"react\";\nfunction useKeyPress(targetKey) {\n  const [pressed, setPressed] = useState(false);\n  useEffect(() => {\n    const ks = Array.isArray(targetKey) ? targetKey : [targetKey];\n    const onDown = (e) => {\n      if (ks.includes(e.key))\n        setPressed(true);\n    };\n    const onUp = (e) => {\n      if (ks.includes(e.key))\n        setPressed(false);\n    };\n    window.addEventListener(\"keydown\", onDown);\n    window.addEventListener(\"keyup\", onUp);\n    return () => {\n      window.removeEventListener(\"keydown\", onDown);\n      window.removeEventListener(\"keyup\", onUp);\n    };\n  }, [targetKey]);\n  return pressed;\n}\nexport {\n  useKeyPress\n};\n",
  "useLocalStorage": "import { useCallback, useEffect, useState } from \"react\";\nimport { isClient } from \"../utils/ssr\";\nfunction useLocalStorage(key, initial) {\n  const read = () => {\n    if (!isClient)\n      return typeof initial === \"function\" ? initial() : initial;\n    try {\n      const raw = localStorage.getItem(key);\n      return raw ? JSON.parse(raw) : typeof initial === \"function\" ? initial() : initial;\n    } catch (err) {\n      console.warn(\"useLocalStorage: error reading\", err);\n      return typeof initial === \"function\" ? initial() : initial;\n    }\n  };\n  const [state, setState] = useState(read);\n  useEffect(() => {\n    if (!isClient)\n      return;\n    try {\n      localStorage.setItem(key, JSON.stringify(state));\n    } catch (err) {\n      console.warn(\"useLocalStorage: error writing\", err);\n    }\n  }, [key, state]);\n  const remove = useCallback(() => {\n    if (!isClient)\n      return;\n    try {\n      localStorage.removeItem(key);\n      setState(typeof initial === \"function\" ? initial() : initial);\n    } catch (err) {\n      console.warn(\"useLocalStorage: remove failed\", err);\n    }\n  }, [key, initial]);\n  return [state, setState, remove];\n}\nexport {\n  useLocalStorage\n};\n",
  "useMediaQuery": "import { useEffect, useState } from \"react\";\nfunction useMediaQuery(query) {\n  const isClient = typeof window !== \"undefined\";\n  const [matches, setMatches] = useState(() => isClient ? window.matchMedia(query).matches : false);\n  useEffect(() => {\n    if (!isClient)\n      return;\n    const mq = window.matchMedia(query);\n    const listener = (e) => setMatches(e.matches);\n    if (typeof mq.addEventListener === \"function\") {\n      mq.addEventListener(\"change\", listener);\n      return () => mq.removeEventListener(\"change\", listener);\n    } else {\n      const legacy = mq;\n      if (legacy.addListener)\n        legacy.addListener(listener);\n      return () => {\n        if (legacy.removeListener)\n          legacy.removeListener(listener);\n      };\n    }\n  }, [query, isClient]);\n  return matches;\n}\nexport {\n  useMediaQuery\n};\n",
  "useOnlineStatus": "import { useEffect, useState } from \"react\";\nfunction useOnlineStatus() {\n  const isClient = typeof navigator !== \"undefined\" && \"onLine\" in navigator;\n  const [online, setOnline] = useState(() => isClient ? navigator.onLine : true);\n  useEffect(() => {\n    if (!isClient)\n      return;\n    const onOnline = () => setOnline(true);\n    const onOffline = () => setOnline(false);\n    window.addEventListener(\"online\", onOnline);\n    window.addEventListener(\"offline\", onOffline);\n    return () => {\n      window.removeEventListener(\"online\", onOnline);\n      window.removeEventListener(\"offline\", onOffline);\n    };\n  }, [isClient]);\n  return online;\n}\nexport {\n  useOnlineStatus\n};\n",
  "usePaginatedFetch": "import { useCallback, useState } from \"react\";\nimport { useFetch } from \"./useFetch\";\nfunction usePaginatedFetch(baseUrl, pageSize = 10) {\n  const [page, setPage] = useState(1);\n  const url = `${baseUrl}${baseUrl.includes(\"?\") ? \"&\" : \"?\"}_page=${page}&_limit=${pageSize}`;\n  const res = useFetch(url);\n  const next = useCallback(() => setPage((p) => p + 1), []);\n  const prev = useCallback(() => setPage((p) => Math.max(1, p - 1)), []);\n  const reset = useCallback(() => setPage(1), []);\n  return { ...res, page, next, prev, reset };\n}\nexport {\n  usePaginatedFetch\n};\n",
  "usePolling": "import { useEffect, useRef } from \"react\";\nfunction usePolling(fn, interval) {\n  const saved = useRef(fn);\n  useEffect(() => {\n    saved.current = fn;\n  }, [fn]);\n  useEffect(() => {\n    if (interval == null)\n      return;\n    let mounted = true;\n    const tick = async () => {\n      if (!mounted)\n        return;\n      await saved.current();\n    };\n    const id = setInterval(tick, interval);\n    return () => {\n      mounted = false;\n      clearInterval(id);\n    };\n  }, [interval]);\n}\nexport {\n  usePolling\n};\n",
  "usePreferredLanguage": "import { useMemo } from \"react\";\nfunction usePreferredLanguage() {\n  const isClient = typeof navigator !== \"undefined\";\n  return useMemo(() => {\n    if (!isClient)\n      return { language: \"en\", languages: [\"en\"] };\n    return { language: navigator.language || \"en\", languages: navigator.languages || [navigator.language || \"en\"] };\n  }, [isClient]);\n}\nexport {\n  usePreferredLanguage\n};\n",
  "usePrevious": "import { useEffect, useRef, useState } from \"react\";\nfunction usePrevious(value) {\n  const curRef = useRef(void 0);\n  const [prev, setPrev] = useState(void 0);\n  useEffect(() => {\n    setPrev(curRef.current);\n    curRef.current = value;\n  }, [value]);\n  return prev;\n}\nexport {\n  usePrevious\n};\n",
  "useReducedMotion": "import { useEffect, useState } from \"react\";\nfunction useReducedMotion() {\n  const isClient = typeof window !== \"undefined\";\n  const [reduced, setReduced] = useState(() => isClient ? window.matchMedia(\"(prefers-reduced-motion: reduce)\").matches : false);\n  useEffect(() => {\n    if (!isClient)\n      return;\n    const mq = window.matchMedia(\"(prefers-reduced-motion: reduce)\");\n    const onChange = (e) => setReduced(e.matches);\n    if (typeof mq.addEventListener === \"function\") {\n      mq.addEventListener(\"change\", onChange);\n      return () => mq.removeEventListener(\"change\", onChange);\n    }\n    const legacy = mq;\n    if (legacy.addListener)\n      legacy.addListener(onChange);\n    return () => {\n      if (legacy.removeListener)\n        legacy.removeListener(onChange);\n    };\n  }, [isClient]);\n  return reduced;\n}\nexport {\n  useReducedMotion\n};\n",
  "useRenderCount": "import { useEffect, useState } from \"react\";\nfunction useRenderCount() {\n  const [count, setCount] = useState(1);\n  useEffect(() => {\n    const id = setTimeout(() => setCount((c) => c + 1), 0);\n    return () => clearTimeout(id);\n  });\n  return count;\n}\nexport {\n  useRenderCount\n};\n",
  "useResizeObserver": "import { useEffect, useRef, useState } from \"react\";\nfunction useResizeObserver() {\n  const obsRef = useRef(null);\n  const [size, setSize] = useState({ width: 0, height: 0 });\n  useEffect(() => {\n    if (typeof ResizeObserver === \"undefined\")\n      return;\n    obsRef.current = new ResizeObserver((entries) => {\n      const e = entries[0];\n      if (!e)\n        return;\n      const cr = e.contentRect;\n      setSize({ width: cr.width, height: cr.height });\n    });\n    return () => {\n      var _a;\n      return (_a = obsRef.current) == null ? void 0 : _a.disconnect();\n    };\n  }, []);\n  const observe = (el) => {\n    if (el && obsRef.current)\n      obsRef.current.observe(el);\n  };\n  const unobserve = (el) => {\n    if (el && obsRef.current)\n      obsRef.current.unobserve(el);\n  };\n  return { size, observe, unobserve };\n}\nexport {\n  useResizeObserver\n};\n",
  "useScrollPosition": "import { useEffect, useState } from \"react\";\nfunction useScrollPosition() {\n  const isClient = typeof window !== \"undefined\";\n  const [pos, setPos] = useState(() => ({ x: isClient ? window.scrollX : 0, y: isClient ? window.scrollY : 0 }));\n  useEffect(() => {\n    if (!isClient)\n      return;\n    const handler = () => setPos({ x: window.scrollX, y: window.scrollY });\n    window.addEventListener(\"scroll\", handler, { passive: true });\n    return () => window.removeEventListener(\"scroll\", handler);\n  }, [isClient]);\n  return pos;\n}\nexport {\n  useScrollPosition\n};\n",
  "useSessionStorage": "import { useCallback, useEffect, useState } from \"react\";\nimport { isClient } from \"../utils/ssr\";\nfunction useSessionStorage(key, initial) {\n  const read = () => {\n    if (!isClient)\n      return typeof initial === \"function\" ? initial() : initial;\n    try {\n      const raw = sessionStorage.getItem(key);\n      return raw ? JSON.parse(raw) : typeof initial === \"function\" ? initial() : initial;\n    } catch (err) {\n      console.warn(\"useSessionStorage: error reading\", err);\n      return typeof initial === \"function\" ? initial() : initial;\n    }\n  };\n  const [state, setState] = useState(read);\n  useEffect(() => {\n    if (!isClient)\n      return;\n    try {\n      sessionStorage.setItem(key, JSON.stringify(state));\n    } catch (err) {\n      console.warn(\"useSessionStorage: error writing\", err);\n    }\n  }, [key, state]);\n  const remove = useCallback(() => {\n    if (!isClient)\n      return;\n    try {\n      sessionStorage.removeItem(key);\n      setState(typeof initial === \"function\" ? initial() : initial);\n    } catch (err) {\n      console.warn(\"useSessionStorage: remove failed\", err);\n    }\n  }, [key, initial]);\n  return [state, setState, remove];\n}\nexport {\n  useSessionStorage\n};\n",
  "useThrottle": "import { useEffect, useRef, useState } from \"react\";\nfunction useThrottle(value, limit = 200) {\n  const [throttled, setThrottled] = useState(value);\n  const lastRun = useRef(null);\n  const timeout = useRef(null);\n  useEffect(() => {\n    const now = Date.now();\n    if (lastRun.current == null || now - lastRun.current >= limit) {\n      lastRun.current = now;\n      const id = window.setTimeout(() => setThrottled(value), 0);\n      return () => clearTimeout(id);\n    }\n    if (timeout.current)\n      window.clearTimeout(timeout.current);\n    const remaining = limit - (now - (lastRun.current || 0));\n    timeout.current = window.setTimeout(() => {\n      lastRun.current = Date.now();\n      setThrottled(value);\n    }, remaining);\n    return () => {\n      if (timeout.current)\n        window.clearTimeout(timeout.current);\n    };\n  }, [value, limit]);\n  return throttled;\n}\nexport {\n  useThrottle\n};\n",
  "useTimeout": "import { useEffect, useRef } from \"react\";\nfunction useTimeout(cb, delay) {\n  const saved = useRef(cb);\n  useEffect(() => {\n    saved.current = cb;\n  }, [cb]);\n  useEffect(() => {\n    if (delay == null)\n      return;\n    const id = setTimeout(() => saved.current(), delay);\n    return () => clearTimeout(id);\n  }, [delay]);\n}\nexport {\n  useTimeout\n};\n",
  "useToggle": "import { useCallback, useState } from \"react\";\nfunction useToggle(initial = false) {\n  const [state, setState] = useState(initial);\n  const toggle = useCallback(() => setState((s) => !s), []);\n  const setOn = useCallback(() => setState(true), []);\n  const setOff = useCallback(() => setState(false), []);\n  return [state, toggle, setOn, setOff];\n}\nexport {\n  useToggle\n};\n",
  "useUnmount": "import { useEffect } from \"react\";\nfunction useUnmount(fn) {\n  useEffect(() => () => fn(), [fn]);\n}\nexport {\n  useUnmount\n};\n",
  "useVirtualList": "import { useCallback, useMemo, useState } from \"react\";\nfunction useVirtualList(items, itemHeight, containerHeight, overscan = 2) {\n  const [scrollTop, setScrollTop] = useState(0);\n  const onScroll = useCallback((e) => {\n    const el = e.target;\n    setScrollTop(el.scrollTop);\n  }, []);\n  const totalHeight = items.length * itemHeight;\n  const start = Math.max(0, Math.floor(scrollTop / itemHeight) - overscan);\n  const visibleCount = Math.ceil(containerHeight / itemHeight) + overscan * 2;\n  const end = Math.min(items.length, start + visibleCount);\n  const visible = useMemo(() => items.slice(start, end), [items, start, end]);\n  const containerStyle = { height: containerHeight, overflowY: \"auto\" };\n  const spacerStyle = { height: totalHeight };\n  return { visible, start, onScroll, containerStyle, spacerStyle };\n}\nexport {\n  useVirtualList\n};\n",
  "useWebSocket": "import { useCallback, useEffect, useRef, useState } from \"react\";\nfunction useWebSocket(url, protocols) {\n  const wsRef = useRef(null);\n  const [lastMessage, setLastMessage] = useState(null);\n  const [readyState, setReadyState] = useState(WebSocket.CONNECTING);\n  const connect = useCallback(() => {\n    var _a;\n    (_a = wsRef.current) == null ? void 0 : _a.close();\n    const ws = new WebSocket(url, protocols);\n    wsRef.current = ws;\n    setReadyState(ws.readyState);\n    ws.onopen = () => setReadyState(ws.readyState);\n    ws.onclose = () => setReadyState(ws.readyState);\n    ws.onerror = () => setReadyState(ws.readyState);\n    ws.onmessage = (m) => setLastMessage(m);\n  }, [url, protocols]);\n  const send = useCallback((data) => {\n    if (wsRef.current && wsRef.current.readyState === WebSocket.OPEN)\n      wsRef.current.send(data);\n  }, []);\n  const disconnect = useCallback(() => {\n    var _a;\n    (_a = wsRef.current) == null ? void 0 : _a.close();\n  }, []);\n  useEffect(() => {\n    const id = setTimeout(() => connect(), 0);\n    return () => {\n      clearTimeout(id);\n      disconnect();\n    };\n  }, [connect, disconnect]);\n  return { send, lastMessage, readyState, connect, disconnect };\n}\nexport {\n  useWebSocket\n};\n",
  "useWhyDidYouUpdate": "import { useEffect, useRef } from \"react\";\nfunction useWhyDidYouUpdate(name, props) {\n  const prev = useRef(null);\n  useEffect(() => {\n    if (prev.current == null) {\n      prev.current = props;\n      return;\n    }\n    const changed = {};\n    for (const key of Object.keys({ ...prev.current, ...props })) {\n      if (prev.current[key] !== props[key])\n        changed[key] = { from: prev.current[key], to: props[key] };\n    }\n    if (Object.keys(changed).length) {\n      console.log(\"[why-did-you-update]\", name, changed);\n    }\n    prev.current = props;\n  }, [name, props]);\n}\nexport {\n  useWhyDidYouUpdate\n};\n",
  "useWindowSize": "import { useEffect, useState } from \"react\";\nfunction useWindowSize() {\n  const isClient = typeof window !== \"undefined\";\n  const [size, setSize] = useState(() => ({ width: isClient ? window.innerWidth : 0, height: isClient ? window.innerHeight : 0 }));\n  useEffect(() => {\n    if (!isClient)\n      return;\n    const handler = () => setSize({ width: window.innerWidth, height: window.innerHeight });\n    window.addEventListener(\"resize\", handler);\n    return () => window.removeEventListener(\"resize\", handler);\n  }, [isClient]);\n  return size;\n}\nexport {\n  useWindowSize\n};\n",
  "useWorker": "import { useCallback, useEffect, useRef } from \"react\";\nfunction useWorker(script) {\n  const workerRef = useRef(null);\n  const urlRef = useRef(null);\n  useEffect(() => {\n    let created = false;\n    if (typeof script === \"function\") {\n      const body = `(${script.toString()})(self)`;\n      const blob = new Blob([body], { type: \"application/javascript\" });\n      const url = URL.createObjectURL(blob);\n      urlRef.current = url;\n      workerRef.current = new Worker(url);\n      created = true;\n    } else {\n      workerRef.current = new Worker(script);\n    }\n    return () => {\n      var _a;\n      (_a = workerRef.current) == null ? void 0 : _a.terminate();\n      if (created && urlRef.current) {\n        URL.revokeObjectURL(urlRef.current);\n        urlRef.current = null;\n      }\n    };\n  }, [script]);\n  const post = useCallback((msg) => {\n    var _a;\n    return (_a = workerRef.current) == null ? void 0 : _a.postMessage(msg);\n  }, []);\n  const terminate = useCallback(() => {\n    var _a;\n    return (_a = workerRef.current) == null ? void 0 : _a.terminate();\n  }, []);\n  return { workerRef, post, terminate };\n}\nexport {\n  useWorker\n};\n"
}